# Embedded Software Development - Debugging

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [VS Code Setup for C/C++ Development](#vs-code-setup-for-cc-development)
3. [Debugging C/C++ Programs in VS Code](#debugging-cc-programs-in-vs-code)
4. [Command Line Debugging Tools](#command-line-debugging-tools)
5. [Embedded Systems Debugging](#embedded-systems-debugging)
6. [GNU Arm Toolchain](#gnu-arm-toolchain)
7. [Arm Compiler for Embedded](#arm-compiler-for-embedded)
8. [Assembly Language Development & Debugging](#assembly-language-development--debugging)
9. [Assembly Debugging](ASSEMBLY_DEBUG.md)
10. [Yocto Project Debugging](#yocto-project-debugging)
11. [Advanced Debugging Techniques](#advanced-debugging-techniques)
12. [Conclusion: Assembly Debugging](#conclusion-assembly-debugging)
13. [Inter-Process Communication (IPC) Debugging](#inter-process-communication-ipc-debugging)
14. [What is Cross Compilation?](#what-is-cross-compilation)
15. [Troubleshooting](#troubleshooting)

## Prerequisites

### System Requirements
- Linux Distribution (Ubuntu/Debian recommended)
- Visual Studio Code
- GCC/G++ compiler
- GDB debugger

### Install Essential Tools

```bash
# Update package lists
sudo apt-get update

# Install build-essential and GDB
sudo apt-get install build-essential gdb

# Verify installation
gcc --version
gdb --version
```

## VS Code Setup for C/C++ Development

### 1. Install Visual Studio Code

Download and install VS Code for Linux from the [official website](https://code.visualstudio.com/download).

### 2. Install Required Extensions

Install these essential extensions from the VS Code marketplace:

#### Core Extensions
- **C/C++ Extension (ms-vscode.cpptools)**: Provides IntelliSense, debugging, and code navigation
- **C/C++ Extension Pack**: Includes additional tools for C/C++ development
- **CMake Tools**: For CMake-based projects
- **GitLens**: Enhanced Git capabilities

#### Embedded Development Extensions
- **Embedded Tools Extension**: Facilitates embedded development with toolchain acquisition
- **PlatformIO IDE**: Embedded development platform
- **Cortex-Debug**: ARM Cortex debugging support

### 3. Workspace Configuration

Create a new C++ project:

```bash
mkdir my_cpp_project
cd my_cpp_project
code .
```

VS Code will create a `.vscode` folder with important configuration files.

#### tasks.json (Build Configuration)
```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "type": "shell",
      "label": "C/C++: g++ build active file",
      "command": "/usr/bin/g++",
      "args": [
        "-g",
        "-std=c++17",
        "${file}",
        "-o",
        "${fileDirname}/${fileBasenameNoExtension}"
      ],
      "options": {
        "cwd": "/usr/bin"
      },
      "problemMatcher": ["$gcc"],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Task generated by Debugger."
    }
  ]
}
```

#### launch.json (Debug Configuration)
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "C/C++: g++ build and debug active file",
      "type": "cppdbg",
      "request": "launch",
      "program": "${fileDirname}/${fileBasenameNoExtension}",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "C/C++: g++ build active file"
    }
  ]
}
```

#### c_cpp_properties.json (IntelliSense Configuration)
```json
{
  "configurations": [
    {
      "name": "Linux",
      "includePath": [
        "${workspaceFolder}/**"
      ],
      "defines": [],
      "compilerPath": "/usr/bin/gcc",
      "cStandard": "c11",
      "cppStandard": "c++17",
      "intelliSenseMode": "clang-x64"
    }
  ],
  "version": 4
}
```

## Debugging C/C++ Programs in VS Code

### Setting Up Debug Environment

1. **Create a Simple C++ Program**:
```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main() {
    vector<string> msg {"Hello", "C++", "World", "from", "VS Code"};
    
    for (const string& word : msg) {
        cout << word << " ";
    }
    cout << endl;
    
    return 0;
}
```

2. **Set Breakpoints**:
   - Click on the left margin next to line numbers
   - Use `F9` to toggle breakpoints
   - Red dots indicate active breakpoints

3. **Start Debugging**:
   - Press `F5` or use the debug icon
   - Select "Debug C/C++ File"
   - Choose appropriate compiler configuration

### Debugging Features

#### Basic Debugging Controls
- **F5**: Start/Continue debugging
- **F10**: Step Over
- **F11**: Step Into
- **Shift+F11**: Step Out
- **Ctrl+Shift+F5**: Restart
- **Shift+F5**: Stop

#### Advanced Debugging Features

**1. Conditional Breakpoints**:
- Right-click on breakpoint â†’ "Edit Breakpoint"
- Add condition (e.g., `i > 5`)

**2. Function Breakpoints**:
- In Run view, right-click "Breakpoints" section
- "Add Function Breakpoint"
- Enter function name

**3. Watch Variables**:
- Add variables to Watch panel
- Expressions are evaluated continuously
- Hover over variables for quick inspection

**4. Call Stack Inspection**:
- View function call hierarchy
- Navigate through stack frames
- Inspect local variables at each level

## Command Line Debugging Tools

### GDB (GNU Debugger)

#### Basic GDB Commands

```bash
# Compile with debug symbols
gcc -g -o myprogram myprogram.c

# Start GDB
gdb ./myprogram

# Essential GDB commands
(gdb) run                    # Start program
(gdb) break main            # Set breakpoint at main
(gdb) break 15              # Set breakpoint at line 15
(gdb) continue              # Continue execution
(gdb) next                  # Step over (next line)
(gdb) step                  # Step into functions
(gdb) print variable_name   # Print variable value
(gdb) list                  # Show source code
(gdb) info registers        # Show CPU registers
(gdb) backtrace            # Show call stack
(gdb) quit                 # Exit GDB
```

#### Advanced GDB Debugging

**Memory Debugging**:
```bash
(gdb) x/10x 0x601040       # Examine 10 hex words at address
(gdb) x/s string_ptr       # Examine string
(gdb) watch variable_name  # Watch variable changes
```

**Core Dump Analysis**:
```bash
# Generate core dump
ulimit -c unlimited
./myprogram  # Program crashes

# Analyze core dump
gdb ./myprogram core
(gdb) bt     # Show backtrace of crash
```

### Valgrind (Memory Debugging)

```bash
# Install Valgrind
sudo apt-get install valgrind

# Memory leak detection
valgrind --tool=memcheck --leak-check=full ./myprogram

# Thread error detection
valgrind --tool=helgrind ./myprogram
```

### Strace (System Call Tracing)

```bash
# Trace system calls
strace ./myprogram

# Trace specific system calls
strace -e open,read,write ./myprogram

# Attach to running process
strace -p <PID>
```

## Embedded Systems Debugging

### Embedded Tools in VS Code

VS Code provides specialized tools for embedded development through the **Embedded Tools Extension**:

#### Key Features:
- **vcpkg Integration**: Automatic toolchain acquisition
- **Peripheral Register Views**: SVD file support
- **RTOS Object Views**: Thread and kernel object inspection
- **Hardware Breakpoint Management**: Limited breakpoint handling
- **Cross-compilation Support**: ARM, RISC-V, and other architectures

#### Installation and Setup:
1. Install "Embedded Tools" extension
2. Use vcpkg to acquire toolchain dependencies
3. Configure launch.json for target hardware
4. Set up OpenOCD or similar debug adapter

### Hardware Debugging Setup

#### OpenOCD Configuration
```json
{
  "name": "Embedded Debug",
  "type": "cppdbg",
  "request": "launch",
  "program": "${workspaceFolder}/build/firmware.elf",
  "miDebuggerPath": "arm-none-eabi-gdb",
  "miDebuggerServerAddress": "localhost:3333",
  "debugServerPath": "openocd",
  "debugServerArgs": [
    "-f", "interface/stlink.cfg",
    "-f", "target/stm32f4x.cfg"
  ],
  "svdPath": "${workspaceFolder}/STM32F407.svd",
  "stopAtConnect": true
}
```

#### Peripheral Register Debugging:
- Load SVD (System View Description) files
- View and modify peripheral registers
- Real-time register monitoring during debugging

#### RTOS Debugging:
- Thread stack analysis
- Kernel object inspection (mutexes, semaphores, queues)
- Task scheduling visualization

## GNU Arm Toolchain

The GNU Arm Toolchain is the de facto standard for ARM Cortex development:

### Components:
- **GCC**: GNU Compiler Collection for ARM
- **GAS**: GNU Assembler
- **LD**: GNU Linker
- **GDB**: GNU Debugger with ARM extensions
- **Binutils**: Binary utilities (objcopy, objdump, etc.)

### Installation:
```bash
# Ubuntu/Debian
sudo apt-get install gcc-arm-none-eabi gdb-arm-none-eabi

# Verify installation
arm-none-eabi-gcc --version
arm-none-eabi-gdb --version
```

### Cross-Compilation Example:
```bash
# Compile for ARM Cortex-M4
arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -g -O2 \
  -T linker_script.ld -o firmware.elf main.c startup.s

# Generate hex file for flashing
arm-none-eabi-objcopy -O ihex firmware.elf firmware.hex

# Disassemble for analysis
arm-none-eabi-objdump -d firmware.elf > firmware.dis
```

### Key Compiler Flags:
- `-mcpu=cortex-m4`: Target ARM Cortex-M4
- `-mthumb`: Use Thumb instruction set
- `-mfloat-abi=hard`: Hardware floating point
- `-g`: Include debug symbols
- `-Os`: Optimize for size
- `-ffunction-sections`: Enable dead code elimination

## Arm Compiler for Embedded

ARM's commercial compiler offering optimized performance and additional features:

### Key Features:
- **armclang**: LLVM/Clang-based compiler
- **armlink**: Advanced linker with scatter-loading
- **ARM C/C++ Libraries**: Optimized runtime libraries
- **fromelf**: Image conversion and disassembly tool

### Comparison with GNU Toolchain:
- Better code optimization
- Official ARM support
- Advanced debugging features
- Commercial licensing required
- Functional safety certification available

### Integration with VS Code:
```json
{
  "compilerPath": "/opt/arm/bin/armclang",
  "cStandard": "c11",
  "cppStandard": "c++14",
  "intelliSenseMode": "clang-arm"
}
```

## Assembly Language Development & Debugging

Assembly language programming and debugging is crucial for embedded systems development, providing direct hardware control and optimal performance. This section covers assembly debugging techniques for both DevOps and development teams.

### DevOps Setup for Assembly Debugging

#### System-wide Assembly Debugging Environment

**1. Install Assembly Development Tools**:
```bash
#!/bin/bash
# DevOps setup script for assembly debugging environment

# Update system
sudo apt-get update && sudo apt-get upgrade -y

# Install essential assembly development tools
sudo apt-get install -y \
    binutils \
    gdb \
    nasm \
    yasm \
    gas \
    build-essential \
    libc6-dev \
    strace \
    ltrace \
    hexdump \
    objdump \
    readelf \
    nm \
    strings

# Install debugging and analysis tools
sudo apt-get install -y \
    valgrind \
    gdb-multiarch \
    qemu-user \
    qemu-system \
    lldb

# Install VS Code extensions (if using VS Code)
code --install-extension ms-vscode.cpptools
code --install-extension13xforever.language-x86-64-assembly
code --install-extension maziac.asm-code-lens
```

**2. Configure Debugging Environment**:
```bash
# Set up debugging permissions
echo 'kernel.yama.ptrace_scope = 0' | sudo tee -a /etc/sysctl.conf
sudo sysctl -p

# Create debugging workspace structure
mkdir -p ~/assembly-debug/{src,build,tools,scripts}
cd ~/assembly-debug

# Create build script
cat > build_debug.sh << 'EOF'
#!/bin/bash
# Assembly build script with debugging symbols

ASM_FILE="$1"
OUTPUT_NAME="${ASM_FILE%.*}"

echo "Building $ASM_FILE with debug symbols..."

# Assemble with debug info
as --64 --gstabs+ "$ASM_FILE" -o "${OUTPUT_NAME}.o"

# Link with debug info  
ld "${OUTPUT_NAME}.o" -o "$OUTPUT_NAME"

echo "Debug build complete: $OUTPUT_NAME"
echo "Object file: ${OUTPUT_NAME}.o"
EOF

chmod +x build_debug.sh
```

### x86-64 Assembly Programming & Debugging

#### Complete Hello World Example (src/hello.s)

Our hello.s file demonstrates system calls and basic assembly structure:

```assembly
.section .data
    hello_msg: .ascii "Hello World from Assembly!\n"
    hello_len = . - hello_msg

.section .text
    .global _start

_start:
    # sys_write system call
    mov $1, %rax        # system call number for sys_write
    mov $1, %rdi        # file descriptor 1 (stdout)
    mov $hello_msg, %rsi # message to write
    mov $hello_len, %rdx # message length
    syscall             # call kernel

    # sys_exit system call
    mov $60, %rax       # system call number for sys_exit
    mov $0, %rdi        # exit status
    syscall             # call kernel
```

#### Enhanced Build Process with Debug Symbols:

**1. Manual Build Process**:
```bash
# Method 1: Using GNU Assembler (GAS) with debug symbols
as --64 --gstabs+ hello.s -o hello.o
ld hello.o -o hello

# Method 2: Using GCC for better debug integration
gcc -nostdlib -static hello.s -o hello

# Method 3: Using NASM (alternative assembler)
nasm -f elf64 -g -F dwarf hello_nasm.asm -o hello_nasm.o
ld hello_nasm.o -o hello_nasm

# Verify debug symbols are present
objdump -h hello | grep debug
readelf -S hello | grep debug
```

**2. Automated Build Script**:
```bash
#!/bin/bash
# enhanced_build.sh - Assembly build script

set -e

ASM_FILE="${1:-hello.s}"
OUTPUT_NAME="${ASM_FILE%.*}"

echo "=== Assembly Build & Debug Setup ==="
echo "Source: $ASM_FILE"
echo "Output: $OUTPUT_NAME"

# Clean previous builds
rm -f "${OUTPUT_NAME}.o" "$OUTPUT_NAME"

# Build with multiple debug formats
echo "Building with debug symbols..."
as --64 --gstabs+ --gdwarf-4 "$ASM_FILE" -o "${OUTPUT_NAME}.o"
ld "${OUTPUT_NAME}.o" -o "$OUTPUT_NAME"

# Generate additional debug information
echo "Generating debug information..."
objdump -d "$OUTPUT_NAME" > "${OUTPUT_NAME}.dis"
objdump -s "$OUTPUT_NAME" > "${OUTPUT_NAME}.hex"
readelf -a "$OUTPUT_NAME" > "${OUTPUT_NAME}.elf"

echo "=== Build Complete ==="
echo "Executable: $OUTPUT_NAME"
echo "Disassembly: ${OUTPUT_NAME}.dis"
echo "Hex dump: ${OUTPUT_NAME}.hex"
echo "ELF info: ${OUTPUT_NAME}.elf"
```

### VS Code Assembly Debugging Capabilities

**Yes, VS Code can effectively debug assembly code!** Here's how to set it up:

#### VS Code Assembly Extensions

**Required Extensions**:
```bash
# Install assembly-specific extensions
code --install-extension 13xforever.language-x86-64-assembly
code --install-extension maziac.asm-code-lens
code --install-extension ms-vscode.cpptools
code --install-extension webfreak.debug
```

#### VS Code Configuration for Assembly Debugging

**1. tasks.json for Assembly Build**:
```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "build-assembly",
      "type": "shell",
      "command": "as",
      "args": [
        "--64",
        "--gstabs+",
        "--gdwarf-4",
        "${file}",
        "-o",
        "${fileDirname}/${fileBasenameNoExtension}.o"
      ],
      "group": "build",
      "detail": "Assemble with debug symbols"
    },
    {
      "label": "link-assembly",
      "type": "shell",
      "command": "ld",
      "args": [
        "${fileDirname}/${fileBasenameNoExtension}.o",
        "-o",
        "${fileDirname}/${fileBasenameNoExtension}"
      ],
      "group": "build",
      "dependsOn": "build-assembly",
      "detail": "Link assembly object"
    },
    {
      "label": "build-and-link-assembly",
      "dependsOrder": "sequence",
      "dependsOn": [
        "build-assembly",
        "link-assembly"
      ],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Complete assembly build process"
    }
  ]
}
```

**2. launch.json for Assembly Debugging**:
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug Assembly (hello.s)",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/src/hello",
      "args": [],
      "stopAtEntry": true,
      "cwd": "${workspaceFolder}/src",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        },
        {
          "description": "Set disassembly flavor to Intel",
          "text": "-gdb-set disassembly-flavor intel",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "build-and-link-assembly",
      "logging": {
        "engineLogging": false
      }
    },
    {
      "name": "Debug Assembly (Custom)",
      "type": "cppdbg",
      "request": "launch",
      "program": "${fileDirname}/${fileBasenameNoExtension}",
      "args": [],
      "stopAtEntry": true,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/gdb",
      "setupCommands": [
        {
          "description": "Set disassembly flavor",
          "text": "-gdb-set disassembly-flavor intel"
        },
        {
          "description": "Show registers in hex",
          "text": "-gdb-set output-radix 16"
        }
      ],
      "preLaunchTask": "build-and-link-assembly"
    }
  ]
}
```

**3. c_cpp_properties.json for Assembly IntelliSense**:
```json
{
  "configurations": [
    {
      "name": "Linux",
      "includePath": [
        "${workspaceFolder}/**"
      ],
      "defines": [],
      "compilerPath": "/usr/bin/gcc",
      "cStandard": "c17",
      "cppStandard": "c++17",
      "intelliSenseMode": "linux-gcc-x64",
      "compilerArgs": ["-nostdlib"]
    }
  ],
  "version": 4
}
```

### Advanced Assembly Debugging Techniques

#### GDB Assembly Debugging Commands

**Essential Assembly Debugging Commands**:
```bash
# Start GDB with assembly program
gdb ./hello

# Assembly-specific GDB commands
(gdb) set disassembly-flavor intel    # Use Intel syntax
(gdb) layout asm                      # Show assembly layout
(gdb) layout regs                     # Show registers layout
(gdb) break _start                    # Set breakpoint at _start
(gdb) run                            # Start execution

# Stepping through assembly
(gdb) stepi                          # Step one instruction
(gdb) nexti                          # Next instruction (skip calls)
(gdb) stepi 5                        # Step 5 instructions

# Register inspection
(gdb) info registers                 # Show all registers
(gdb) info registers rax rbx rcx     # Show specific registers
(gdb) print $rax                     # Print RAX register
(gdb) print/x $rsp                   # Print RSP in hex
(gdb) print/t $rax                   # Print RAX in binary

# Memory examination
(gdb) x/10i $rip                     # Show next 10 instructions
(gdb) x/8x $rsp                      # Show 8 hex words from stack
(gdb) x/s hello_msg                  # Show string at hello_msg
(gdb) x/8b hello_msg                 # Show 8 bytes at hello_msg

# Disassembly commands
(gdb) disas _start                   # Disassemble _start function
(gdb) disas _start,+20              # Disassemble 20 bytes from _start
(gdb) disas 0x401000,0x401020       # Disassemble address range

# Watchpoints for memory/registers
(gdb) watch $rax                     # Watch RAX register
(gdb) watch *0x402000               # Watch memory location
(gdb) rwatch hello_msg              # Watch for memory reads
```

#### VS Code Assembly Debugging Workflow

**Step-by-Step Debugging Process**:

1. **Open hello.s in VS Code**
2. **Set Breakpoints**: Click on line numbers next to assembly instructions
3. **Start Debugging**: Press F5 or use Debug menu
4. **Use Debug Console**: 
   ```
   -exec info registers
   -exec x/10i $rip
   -exec print $rax
   ```
5. **Step Through Code**: Use F10 (step over) or F11 (step into)
6. **Inspect Variables**: Hover over register names or use Watch panel

#### DevOps Assembly Debugging Scripts

**1. Automated Testing Script**:
```bash
#!/bin/bash
# test_assembly.sh - Automated assembly testing and debugging

ASM_FILE="hello.s"
EXPECTED_OUTPUT="Hello World from Assembly!"

echo "=== Assembly Testing & Debugging ==="

# Build
./build_debug.sh "$ASM_FILE"

# Test execution
echo "Testing program execution..."
OUTPUT=$(./hello)
echo "Program output: $OUTPUT"

# Compare with expected output
if [[ "$OUTPUT" == *"$EXPECTED_OUTPUT"* ]]; then
    echo "âœ“ Test PASSED: Output matches expected result"
else
    echo "âœ— Test FAILED: Output doesn't match expected result"
    exit 1
fi

# Run with strace for system call analysis
echo "Analyzing system calls..."
strace -e write ./hello 2>&1 | grep "Hello World"

# Generate debugging report
echo "=== Debugging Information ==="
file ./hello
objdump -f ./hello
readelf -h ./hello
```

**2. GDB Automation Script**:
```bash
#!/bin/bash
# gdb_auto_debug.sh - Automated GDB debugging session

cat > debug_commands.gdb << 'EOF'
set disassembly-flavor intel
file hello
break _start
run
info registers
x/10i $rip
stepi
info registers rax rdi rsi rdx
x/s hello_msg
continue
quit
EOF

gdb -batch -x debug_commands.gdb
rm debug_commands.gdb
```

### Debugging Assembly in Different Architectures

#### ARM Assembly Debugging Setup:
```bash
# Install ARM tools for cross-debugging
sudo apt-get install gcc-arm-linux-gnueabi gdb-multiarch qemu-user

# ARM assembly example
cat > hello_arm.s << 'EOF'
.section .data
    msg: .ascii "Hello ARM!\n"
    msglen = . - msg

.section .text
.global _start

_start:
    mov r7, #4          @ sys_write
    mov r0, #1          @ stdout
    ldr r1, =msg        @ message
    mov r2, #msglen     @ length
    svc 0               @ system call
    
    mov r7, #1          @ sys_exit
    mov r0, #0          @ status
    svc 0               @ system call
EOF

# Build and debug ARM assembly
arm-linux-gnueabi-as hello_arm.s -o hello_arm.o
arm-linux-gnueabi-ld hello_arm.o -o hello_arm

# Debug with QEMU and GDB
qemu-arm -L /usr/arm-linux-gnueabi -g 1234 ./hello_arm &
gdb-multiarch ./hello_arm
(gdb) target remote :1234
(gdb) break _start
(gdb) continue
```

### DevOps Best Practices for Assembly Development

#### Continuous Integration for Assembly Projects

**1. GitHub Actions Workflow (.github/workflows/assembly-ci.yml)**:
```yaml
name: Assembly CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Assembly Tools
      run: |
        sudo apt-get update
        sudo apt-get install -y binutils gdb nasm yasm strace
        
    - name: Build Assembly Programs
      run: |
        cd src
        as --64 --gstabs+ hello.s -o hello.o
        ld hello.o -o hello
        
    - name: Test Assembly Execution
      run: |
        cd src
        ./hello > output.txt
        if grep -q "Hello World from Assembly" output.txt; then
          echo "âœ“ Assembly program test passed"
        else
          echo "âœ— Assembly program test failed"
          exit 1
        fi
        
    - name: Generate Debug Information
      run: |
        cd src
        objdump -d hello > hello.dis
        readelf -a hello > hello.elf
        
    - name: Archive Build Artifacts
      uses: actions/upload-artifact@v3
      with:
        name: assembly-build-artifacts
        path: |
          src/hello
          src/hello.o
          src/hello.dis
          src/hello.elf
```

**2. Docker Development Environment**:
```dockerfile
# Dockerfile for assembly development environment
FROM ubuntu:22.04

RUN apt-get update && apt-get install -y \
    binutils \
    gdb \
    nasm \
    yasm \
    strace \
    ltrace \
    objdump \
    readelf \
    hexdump \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Set up debugging permissions
RUN echo 'kernel.yama.ptrace_scope = 0' >> /etc/sysctl.conf

WORKDIR /workspace
COPY . .

# Build script
RUN chmod +x build_debug.sh

CMD ["/bin/bash"]
```

#### Monitoring and Logging for Assembly Programs

**1. Performance Monitoring Script**:
```bash
#!/bin/bash
# monitor_assembly.sh - Monitor assembly program performance

PROGRAM="./hello"
LOG_FILE="assembly_performance.log"

echo "=== Assembly Program Monitoring ===" | tee -a "$LOG_FILE"
echo "Timestamp: $(date)" | tee -a "$LOG_FILE"

# System call tracing
echo "System calls:" | tee -a "$LOG_FILE"
strace -c "$PROGRAM" 2>&1 | tee -a "$LOG_FILE"

# Memory usage
echo "Memory usage:" | tee -a "$LOG_FILE"
/usr/bin/time -v "$PROGRAM" 2>&1 | grep "Maximum resident" | tee -a "$LOG_FILE"

# Performance timing
echo "Execution timing:" | tee -a "$LOG_FILE"
time "$PROGRAM" 2>&1 | tee -a "$LOG_FILE"

# Binary analysis
echo "Binary information:" | tee -a "$LOG_FILE"
file "$PROGRAM" | tee -a "$LOG_FILE"
size "$PROGRAM" | tee -a "$LOG_FILE"
```

### Troubleshooting Assembly Debugging

#### Common Assembly Debugging Issues

**1. Symbol Resolution Problems**:
```bash
# Problem: No debug symbols found
# Solution: Ensure proper assembly flags
as --64 --gstabs+ --gdwarf-4 hello.s -o hello.o

# Verify symbols are present
objdump -t hello.o | grep SYMBOL
readelf -S hello | grep debug
```

**2. GDB Display Issues**:
```bash
# Problem: Assembly not showing properly in GDB
# Solution: Configure GDB for assembly debugging
echo "set disassembly-flavor intel" > ~/.gdbinit
echo "set confirm off" >> ~/.gdbinit
echo "define hookpost-stepi" >> ~/.gdbinit
echo "x/i \$rip" >> ~/.gdbinit
echo "end" >> ~/.gdbinit
```

**3. VS Code Assembly Syntax Issues**:
```json
// Problem: Assembly syntax not recognized
// Solution: Configure VS Code file associations
{
  "files.associations": {
    "*.s": "x86_64",
    "*.asm": "x86_64",
    "*.inc": "x86_64"
  },
  "C_Cpp.errorSquiggles": "Disabled"
}
```

### Assembly Debugging Cheat Sheet

#### Quick Reference Commands

**GDB Assembly Commands**:
```bash
# Essential commands for assembly debugging
set disassembly-flavor intel  # Use Intel syntax
layout asm                    # Assembly view
layout regs                   # Register view
info registers               # Show all registers
stepi / si                   # Step instruction
nexti / ni                   # Next instruction
x/10i $rip                   # Show instructions at RIP
break *0x401000             # Break at address
disas _start                # Disassemble function
```

**Register Inspection**:
```bash
# x86-64 register examination
info registers rax rbx rcx rdx    # General purpose registers
info registers rsi rdi rbp rsp    # Index and pointer registers
info registers rip rflags         # Instruction pointer and flags
print/x $rax                      # Print register in hex
print/t $rflags                   # Print flags in binary
```

**Memory Examination**:
```bash
x/10x $rsp          # 10 hex words from stack pointer
x/s hello_msg       # String at label
x/10i _start        # 10 instructions from _start
x/8b hello_msg      # 8 bytes from address
```

### ARM Assembly Development
```assembly
.section .text
.global _start

_start:
    mov r0, #1           @ stdout file descriptor
    ldr r1, =hello_msg   @ message address
    mov r2, #13          @ message length
    mov r7, #4           @ sys_write system call
    svc #0               @ supervisor call

    mov r0, #0           @ exit status
    mov r7, #1           @ sys_exit system call  
    svc #0               @ supervisor call

.section .data
hello_msg: .ascii "Hello ARM!\n"
```

#### ARM GCC Compilation:
```bash
# Cross-compile for ARM
arm-none-eabi-as -o hello.o hello.s
arm-none-eabi-ld -o hello.elf hello.o

# Debug on target or emulator
arm-none-eabi-gdb hello.elf
```

## Assembly Debugging Quick Reference

For a quick reference guide to assembly debugging commands, tools, and workflows, see:

 **[ASSEMBLY_DEBUG.md](ASSEMBLY_DEBUG.md)** - Complete quick reference card covering:
- DevOps setup commands
- Essential assembly build commands
- GDB assembly debugging commands
- VS Code assembly debugging workflow
- Analysis and testing commands
- Debug console commands
- Common register values and system calls
- Troubleshooting guide

This reference card provides all the essential commands and configurations needed for professional assembly debugging in Linux environments.

## Yocto Project Debugging

The Yocto Project creates custom Linux distributions for embedded systems. Debugging involves both application and system-level techniques:

### Yocto Debugging Tools

#### 1. Application Debugging
```bash
# Add debug packages to image
IMAGE_FEATURES += "tools-debug"
EXTRA_IMAGE_FEATURES += "debug-tweaks"

# Install debugging tools
IMAGE_INSTALL_append = " gdb gdbserver strace valgrind"
```

#### 2. Remote Debugging Setup
```bash
# On target device
gdbserver :2345 /path/to/application

# On development machine
target-gdb /path/to/application
(gdb) target remote target-ip:2345
(gdb) continue
```

#### 3. Cross-Development SDK
```bash
# Build SDK
bitbake -c populate_sdk core-image-minimal

# Install SDK
./tmp/deploy/sdk/toolchain-installer.sh

# Source environment
source /opt/poky/environment-setup-cortexa9hf-neon-poky-linux-gnueabi
```

### System-Level Debugging

#### Boot Process Debugging:
- **U-Boot**: Bootloader debugging
- **Kernel**: Early printk, ftrace, dynamic debug
- **Init System**: systemd journal analysis

#### Performance Analysis:
- **perf**: Performance monitoring
- **oprofile**: System profiling
- **ltrace**: Library call tracing

### VS Code Integration with Yocto
```json
{
  "name": "Yocto Remote Debug",
  "type": "cppdbg",
  "request": "launch",
  "program": "/path/to/yocto/binary",
  "miDebuggerPath": "${env:CROSS_COMPILE}gdb",
  "miDebuggerServerAddress": "192.168.1.100:2345",
  "sourceFileMap": {
    "/usr/src/debug": "${workspaceFolder}/src"
  }
}
```

## Advanced Debugging Techniques

### Multi-threaded Debugging
```bash
# GDB thread commands
(gdb) info threads           # List all threads
(gdb) thread 2              # Switch to thread 2
(gdb) thread apply all bt   # Backtrace all threads
(gdb) set scheduler-locking on  # Lock scheduler
```

### Memory and Performance Debugging

#### Address Sanitizer (ASan):
```bash
gcc -fsanitize=address -g -o myprogram myprogram.c
./myprogram
```

#### Thread Sanitizer (TSan):
```bash
gcc -fsanitize=thread -g -o myprogram myprogram.c
./myprogram
```

### Remote Debugging Over SSH
```bash
# Forward GDB port over SSH
ssh -L 2345:localhost:2345 user@target-device

# Connect GDB
(gdb) target remote localhost:2345
```

### Debugging Optimized Code
```bash
# Compile with debug info for optimized code
gcc -O2 -g3 -o myprogram myprogram.c

# GDB settings for optimized code
(gdb) set print pretty on
(gdb) set print object on
(gdb) set print vtbl on
```

### Development Workflow
1. **Code with Debug Symbols**: Always compile with `-g` flag
2. **Use Static Analysis**: Tools like cppcheck, clang-static-analyzer
3. **Version Control**: Git integration with VS Code
4. **Automated Testing**: Unit tests and CI/CD integration
5. **Documentation**: Comment code and maintain README files

### Debugging Strategy
1. **Reproduce Issues**: Create minimal test cases
2. **Log Analysis**: Use proper logging levels
3. **Incremental Debugging**: Test small changes
4. **Hardware-in-Loop**: Test on actual target hardware
5. **Code Review**: Peer review for bug prevention

### Performance Optimization
1. **Profile Before Optimizing**: Use profiling tools
2. **Memory Management**: Avoid leaks and fragmentation
3. **Algorithm Optimization**: Choose efficient algorithms
4. **Hardware Utilization**: Leverage target-specific features
5. **Real-time Constraints**: Meet timing requirements

## Conclusion: Assembly Debugging

This document demonstrates that **VS Code can effectively debug assembly code** when properly configured. The debugging capabilities include:

### VS Code Assembly Debugging Capabilities

**âœ“ Assembly Debugging:**
- Breakpoint setting on assembly instructions
- Step-by-step instruction execution (F10/F11)
- Register inspection and monitoring
- Memory examination through Debug Console
- GDB command execution via `-exec` commands
- Assembly syntax highlighting with extensions

**âœ“ Development Workflow:**
- Automated build tasks (Ctrl+Shift+P â†’ Tasks)
- Integrated debugging (F5 to start debugging)
- Multiple debugging configurations
- Terminal integration for command-line tools

### DevOps Assembly Debugging

The provided DevOps setup (`devops_setup.sh`) creates a complete assembly debugging environment:

**Infrastructure Components:**
- **Automated toolchain installation** (GDB, assemblers, analysis tools)
- **VS Code workspace configuration** with assembly-optimized settings
- **Build automation scripts** with debug symbol generation
- **Testing frameworks** for assembly program validation
- **CI/CD pipeline templates** for automated testing
- **Monitoring and logging** for performance analysis

**Quick Start for DevOps Teams:**
```bash
# Complete environment setup
./devops_setup.sh

# Demonstration of debugging capabilities
./demo_assembly_debug.sh

# Open optimized workspace in VS Code
code assembly-debug.code-workspace
```

### Practical Assembly Debugging Workflow

*The hello.s example demonstrates debugging capabilities, proving that assembly debugging in Linux with VS Code is not only possible but highly effective for professional embedded systems development.*


**Command Line Debugging (hello.s example):**
```bash
# Build with debug symbols
as --64 --gstabs+ --gdwarf-4 src/hello.s -o hello.o
ld hello.o -o hello

# Debug with GDB
gdb ./hello
(gdb) break _start
(gdb) run
(gdb) stepi                    # Step through each instruction
(gdb) info registers           # View register states
(gdb) x/s $rsi                # Examine string in RSI register
```

**VS Code Debugging (hello.s example):**
1. Open `src/hello.s` in VS Code
2. Click line number next to `_start:` to set breakpoint
3. Press **F5** to start debugging
4. Use **F10** to step through instructions
5. Use Debug Console: `-exec info registers`
6. Watch Variables panel for register changes

### Advanced Debugging Techniques Demonstrated

**1. System Call Analysis:**
```bash
strace ./hello                 # Trace system calls
ltrace ./hello                 # Trace library calls
```

**2. Binary Analysis:**
```bash
objdump -d hello              # Disassemble binary
readelf -a hello              # ELF structure analysis
nm hello                      # Symbol table examination
```

**3. Memory and Performance:**
```bash
valgrind ./hello              # Memory error detection
time ./hello                  # Performance measurement
hexdump -C hello              # Raw binary examination
```

### Cross-Architecture Support

The debugging techniques work across multiple architectures:

**x86-64 (Native):** Full debugging support with all tools
**ARM Cross-Debugging:** Using `gdb-multiarch` and QEMU
**Embedded Targets:** Hardware debugging via OpenOCD/GDB

### DevOps Integration

**Continuous Integration:**
- Automated assembly builds in CI/CD pipelines
- Test framework for assembly program validation
- Performance regression detection
- Cross-platform compatibility testing

## Inter-Process Communication (IPC) Debugging

Inter-Process Communication (IPC) debugging on Linux involves understanding the various IPC mechanisms and utilizing appropriate tools to inspect their behavior. Embedded systems often rely heavily on IPC for communication between processes, drivers, and system components.

### IPC Mechanisms Overview

Linux provides several IPC mechanisms, each with specific debugging approaches:

1. **Pipes and FIFOs (Named Pipes)**
2. **Signals**
3. **Shared Memory**
4. **Message Queues**
5. **Semaphores**
6. **Unix Domain Sockets**
7. **Network Sockets**

### Debugging Pipes and FIFOs

#### Anonymous Pipes
```bash
# Create test pipe program
cat > pipe_test.c << 'EOF'
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <string.h>

int main() {
    int pipefd[2];
    pid_t cpid;
    char buf;
    
    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }
    
    cpid = fork();
    if (cpid == -1) {
        perror("fork");
        return 1;
    }
    
    if (cpid == 0) {    // Child writes to pipe
        close(pipefd[0]);
        write(pipefd[1], "Hello from child\n", 17);
        close(pipefd[1]);
    } else {            // Parent reads from pipe
        close(pipefd[1]);
        while (read(pipefd[0], &buf, 1) > 0)
            write(STDOUT_FILENO, &buf, 1);
        close(pipefd[0]);
        wait(NULL);
    }
    return 0;
}
EOF

# Compile and debug
gcc -g -o pipe_test pipe_test.c

# Debug pipe operations with strace
strace -e trace=pipe,fork,read,write ./pipe_test

# Debug with GDB
gdb ./pipe_test
(gdb) break main
(gdb) run
(gdb) next
(gdb) print pipefd[0]
(gdb) print pipefd[1]
```

#### Named Pipes (FIFOs)
```bash
# Create FIFO for testing
mkfifo test_fifo

# Monitor FIFO operations
strace -e trace=open,read,write,mkfifo -f sh -c 'echo "test message" > test_fifo & cat test_fifo'

# List open FIFOs
lsof | grep FIFO

# Debug FIFO permissions and usage
ls -la test_fifo
stat test_fifo
```

### Signal Debugging

#### Signal Handling Analysis
```bash
# Create signal test program
cat > signal_test.c << 'EOF'
#include <signal.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

void signal_handler(int sig) {
    printf("Received signal %d\n", sig);
}

int main() {
    signal(SIGUSR1, signal_handler);
    printf("PID: %d\n", getpid());
    
    if (fork() == 0) {
        sleep(2);
        kill(getppid(), SIGUSR1);
        return 0;
    }
    
    sleep(5);
    wait(NULL);
    return 0;
}
EOF

gcc -g -o signal_test signal_test.c

# Debug signal delivery
strace -e trace=signal,kill,rt_sigaction ./signal_test

# Monitor signal handling in GDB
gdb ./signal_test
(gdb) break signal_handler
(gdb) run
# In another terminal: kill -USR1 <PID>
```

#### Signal Analysis Tools
```bash
# List process signal handlers
cat /proc/<PID>/status | grep Sig

# Monitor signal masks
strace -e trace=rt_sigprocmask <command>

# Debug signal delivery issues
kill -l                    # List all signals
pgrep -l <process_name>   # Find process PID
kill -USR1 <PID>         # Send test signal
```

### Shared Memory Debugging

#### System V Shared Memory
```bash
# Create shared memory test
cat > shm_test.c << 'EOF'
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
    key_t key = ftok("/tmp", 'A');
    int shmid = shmget(key, 1024, IPC_CREAT | 0666);
    
    if (fork() == 0) {
        // Child process
        char *data = shmat(shmid, NULL, 0);
        strcpy(data, "Hello from child");
        shmdt(data);
        return 0;
    } else {
        // Parent process
        wait(NULL);
        char *data = shmat(shmid, NULL, 0);
        printf("Received: %s\n", data);
        shmdt(data);
        shmctl(shmid, IPC_RMID, NULL);
        return 0;
    }
}
EOF

gcc -g -o shm_test shm_test.c

# Debug shared memory operations
strace -e trace=shmget,shmat,shmdt,shmctl ./shm_test

# Monitor shared memory usage
ipcs -m                   # List shared memory segments
ipcs -m -p                # Show process information
ipcs -m -t                # Show access times
ipcs -m -u                # Show usage information
```

#### POSIX Shared Memory
```bash
# Create POSIX shared memory test
cat > posix_shm_test.c << 'EOF'
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
    const char *name = "/test_shm";
    int fd = shm_open(name, O_CREAT | O_RDWR, 0666);
    ftruncate(fd, 1024);
    
    void *ptr = mmap(NULL, 1024, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    strcpy((char *)ptr, "Hello POSIX SHM");
    printf("Written: %s\n", (char *)ptr);
    
    munmap(ptr, 1024);
    close(fd);
    shm_unlink(name);
    return 0;
}
EOF

gcc -g -o posix_shm_test posix_shm_test.c -lrt

# Debug POSIX shared memory
strace -e trace=shm_open,mmap,munmap,shm_unlink ./posix_shm_test

# Monitor POSIX shared memory
ls /dev/shm/              # List POSIX shared memory objects
```

### Message Queue Debugging

#### System V Message Queues
```bash
# Create message queue test
cat > msgq_test.c << 'EOF'
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/wait.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

struct msg_buffer {
    long msg_type;
    char msg_text[100];
};

int main() {
    key_t key = ftok("/tmp", 'B');
    int msgid = msgget(key, 0666 | IPC_CREAT);
    
    if (fork() == 0) {
        // Child - sender
        struct msg_buffer message;
        message.msg_type = 1;
        strcpy(message.msg_text, "Hello from message queue");
        msgsnd(msgid, &message, sizeof(message.msg_text), 0);
        return 0;
    } else {
        // Parent - receiver
        wait(NULL);
        struct msg_buffer message;
        msgrcv(msgid, &message, sizeof(message.msg_text), 1, 0);
        printf("Received: %s\n", message.msg_text);
        msgctl(msgid, IPC_RMID, NULL);
        return 0;
    }
}
EOF

gcc -g -o msgq_test msgq_test.c

# Debug message queue operations
strace -e trace=msgget,msgsnd,msgrcv,msgctl ./msgq_test

# Monitor message queues
ipcs -q                   # List message queues
ipcs -q -p                # Show process information
ipcs -q -t                # Show access times
```

#### POSIX Message Queues
```bash
# Create POSIX message queue test
cat > posix_mq_test.c << 'EOF'
#include <mqueue.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main() {
    const char *queue_name = "/test_queue";
    struct mq_attr attr;
    attr.mq_flags = 0;
    attr.mq_maxmsg = 10;
    attr.mq_msgsize = 256;
    
    mqd_t mq = mq_open(queue_name, O_CREAT | O_WRONLY, 0644, &attr);
    mq_send(mq, "Hello POSIX MQ", 14, 0);
    mq_close(mq);
    
    mq = mq_open(queue_name, O_RDONLY);
    char buffer[256];
    mq_receive(mq, buffer, 256, NULL);
    printf("Received: %s\n", buffer);
    
    mq_close(mq);
    mq_unlink(queue_name);
    return 0;
}
EOF

gcc -g -o posix_mq_test posix_mq_test.c -lrt

# Debug POSIX message queues
strace -e trace=mq_open,mq_send,mq_receive,mq_unlink ./posix_mq_test

# Monitor POSIX message queues
ls /dev/mqueue/           # List POSIX message queues
```

### Semaphore Debugging

#### System V Semaphores
```bash
# Create semaphore test
cat > sem_test.c << 'EOF'
#include <sys/sem.h>
#include <sys/ipc.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>

union semun {
    int val;
    struct semid_ds *buf;
    unsigned short *array;
};

int main() {
    key_t key = ftok("/tmp", 'C');
    int semid = semget(key, 1, IPC_CREAT | 0666);
    
    // Initialize semaphore
    union semun sem_union;
    sem_union.val = 1;
    semctl(semid, 0, SETVAL, sem_union);
    
    if (fork() == 0) {
        // Child process
        struct sembuf sb = {0, -1, 0};  // Wait (P operation)
        semop(semid, &sb, 1);
        printf("Child acquired semaphore\n");
        sleep(2);
        sb.sem_op = 1;  // Signal (V operation)
        semop(semid, &sb, 1);
        printf("Child released semaphore\n");
        return 0;
    } else {
        // Parent process
        sleep(1);
        struct sembuf sb = {0, -1, 0};
        printf("Parent waiting for semaphore...\n");
        semop(semid, &sb, 1);
        printf("Parent acquired semaphore\n");
        sb.sem_op = 1;
        semop(semid, &sb, 1);
        wait(NULL);
        semctl(semid, 0, IPC_RMID, 0);
        return 0;
    }
}
EOF

gcc -g -o sem_test sem_test.c

# Debug semaphore operations
strace -e trace=semget,semctl,semop ./sem_test

# Monitor semaphores
ipcs -s                   # List semaphores
ipcs -s -p                # Show process information
ipcs -s -t                # Show access times
```

### Unix Domain Socket Debugging

#### Unix Domain Socket Communication
```bash
# Create Unix socket test
cat > unix_socket_test.c << 'EOF'
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <sys/wait.h>

int main() {
    int server_fd, client_fd;
    struct sockaddr_un addr;
    char *socket_path = "/tmp/test_socket";
    
    if (fork() == 0) {
        // Child - server
        server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
        memset(&addr, 0, sizeof(addr));
        addr.sun_family = AF_UNIX;
        strcpy(addr.sun_path, socket_path);
        unlink(socket_path);
        
        bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
        listen(server_fd, 5);
        
        client_fd = accept(server_fd, NULL, NULL);
        char buffer[256];
        read(client_fd, buffer, sizeof(buffer));
        printf("Server received: %s\n", buffer);
        
        close(client_fd);
        close(server_fd);
        unlink(socket_path);
        return 0;
    } else {
        // Parent - client
        sleep(1);
        client_fd = socket(AF_UNIX, SOCK_STREAM, 0);
        memset(&addr, 0, sizeof(addr));
        addr.sun_family = AF_UNIX;
        strcpy(addr.sun_path, socket_path);
        
        connect(client_fd, (struct sockaddr*)&addr, sizeof(addr));
        write(client_fd, "Hello Unix Socket", 17);
        
        close(client_fd);
        wait(NULL);
        return 0;
    }
}
EOF

gcc -g -o unix_socket_test unix_socket_test.c

# Debug Unix socket operations
strace -e trace=socket,bind,listen,accept,connect,read,write ./unix_socket_test

# Monitor Unix sockets
lsof -U                   # List Unix domain sockets
netstat -x                # Show Unix domain socket statistics
```

### IPC Debugging Tools and Techniques

#### System-wide IPC Monitoring
```bash
# List all IPC objects
ipcs -a                   # All IPC objects
ipcs -q -m -s             # All queues, memory, semaphores

# Remove IPC objects (cleanup)
ipcrm -Q <key>            # Remove message queue
ipcrm -M <key>            # Remove shared memory
ipcrm -S <key>            # Remove semaphore set

# Monitor IPC usage
watch -n 1 'ipcs -u'      # Monitor IPC usage in real-time
```

#### Process-specific IPC Analysis
```bash
# Find IPC usage by process
lsof -p <PID> | grep -E "(pipe|socket|FIFO)"

# Monitor process system calls
strace -e trace=ipc -p <PID>

# Monitor file descriptor usage
ls -la /proc/<PID>/fd/

# Check process signal information
cat /proc/<PID>/status | grep -A 20 "Sig"
```

#### Advanced IPC Debugging with BPF/BCC

BCC (BPF Compiler Collection) provides powerful tools for advanced IPC monitoring:

```bash
# Install BCC tools (Ubuntu/Debian)
sudo apt-get install bpfcc-tools linux-headers-$(uname -r)

# Trace IPC system calls
sudo trace-bpfcc 'p:sys_msgget'
sudo trace-bpfcc 'p:sys_shmget'
sudo trace-bpfcc 'p:sys_semget'

# Monitor inter-process communication patterns
sudo execsnoop-bpfcc | grep -E "(pipe|socket)"

# Trace socket operations
sudo tcptracer-bpfcc        # TCP connections
sudo sofdsnoop-bpfcc        # Socket file descriptor operations

# Monitor shared memory access patterns
sudo vfsstat-bpfcc 1        # VFS statistics including shared memory
```

#### Custom BPF Script for IPC Monitoring
```python
#!/usr/bin/env python3
# ipc_monitor.py - Custom BPF script for IPC monitoring

from bcc import BPF

bpf_program = """
#include <uapi/linux/ptrace.h>
#include <linux/sched.h>

BPF_PERF_OUTPUT(events);

struct data_t {
    u32 pid;
    u32 uid;
    char comm[TASK_COMM_LEN];
    char syscall[16];
};

int trace_ipc_syscalls(struct pt_regs *ctx) {
    struct data_t data = {};
    u64 id = bpf_get_current_pid_tgid();
    data.pid = id >> 32;
    data.uid = bpf_get_current_uid_gid();
    bpf_get_current_comm(&data.comm, sizeof(data.comm));
    
    // Get syscall name from probe name
    bpf_probe_read_str(&data.syscall, sizeof(data.syscall), "ipc_call");
    
    events.perf_submit(ctx, &data, sizeof(data));
    return 0;
}
"""

# Usage example - would require full BPF setup
```

### VS Code IPC Debugging Configuration

#### Enhanced launch.json for IPC Debugging
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug IPC Application",
      "type": "cppdbg",
      "request": "launch",
      "program": "${fileDirname}/${fileBasenameNoExtension}",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        },
        {
          "description": "Set environment for IPC debugging",
          "text": "-gdb-set environment MALLOC_CHECK_=3",
          "ignoreFailures": true
        }
      ],
      "logging": {
        "engineLogging": true,
        "trace": true,
        "traceResponse": true
      }
    },
    {
      "name": "Attach to IPC Process",
      "type": "cppdbg",
      "request": "attach",
      "program": "${workspaceFolder}/build/${input:processName}",
      "processId": "${input:processId}",
      "MIMode": "gdb",
      "miDebuggerPath": "/usr/bin/gdb"
    }
  ],
  "inputs": [
    {
      "id": "processId",
      "description": "Process ID to attach to",
      "type": "promptString"
    },
    {
      "id": "processName",
      "description": "Process name",
      "type": "promptString"
    }
  ]
}
```

#### IPC Debugging Tasks
```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Build IPC Test",
      "type": "shell",
      "command": "gcc",
      "args": [
        "-g", "-Wall", "-pthread", "-lrt",
        "${file}",
        "-o", "${fileDirname}/${fileBasenameNoExtension}"
      ],
      "group": "build",
      "problemMatcher": ["$gcc"]
    },
    {
      "label": "Trace IPC System Calls",
      "type": "shell",
      "command": "strace",
      "args": [
        "-e", "trace=ipc,signal,pipe,socket",
        "-f", "-o", "ipc_trace.log",
        "${fileDirname}/${fileBasenameNoExtension}"
      ],
      "group": "test",
      "dependsOn": "Build IPC Test"
    },
    {
      "label": "Monitor IPC Objects",
      "type": "shell",
      "command": "watch",
      "args": ["-n", "1", "ipcs", "-a"],
      "group": "test",
      "isBackground": true
    },
    {
      "label": "Clean IPC Objects",
      "type": "shell",
      "command": "bash",
      "args": [
        "-c",
        "for id in $(ipcs -q | awk 'NR>3 {print $2}'); do ipcrm -q $id; done; for id in $(ipcs -m | awk 'NR>3 {print $2}'); do ipcrm -m $id; done; for id in $(ipcs -s | awk 'NR>3 {print $2}'); do ipcrm -s $id; done"
      ],
      "group": "test"
    }
  ]
}
```

### IPC Performance and Security Debugging

#### Performance Analysis
```bash
# Benchmark IPC mechanisms
time ./pipe_test
time ./shm_test
time ./msgq_test
time ./unix_socket_test

# Memory usage analysis
valgrind --tool=massif ./shm_test
ms_print massif.out.*

# IPC throughput testing
dd if=/dev/zero bs=1M count=100 | ./pipe_test
```

#### Security Analysis
```bash
# Check IPC permissions
ipcs -a -p                # Process ownership
ipcs -a -c                # Creation info
ipcs -a -t                # Time information

# Monitor IPC access attempts
sudo auditctl -w /tmp -p wa -k ipc_access
sudo ausearch -k ipc_access

# SELinux context analysis (if enabled)
ls -Z /tmp/test_*
ps -eZ | grep <process_name>
```

### IPC Debugging Issues and Solutions

#### Deadlocks in IPC
```bash
# Detect deadlocks in applications
gdb -batch -ex "thread apply all bt" -p <PID>

# Monitor waiting processes
ps aux | grep " D "       # Processes in uninterruptible sleep

# Check semaphore values
ipcs -s -i <semid>        # Detailed semaphore info
```

#### Resource Leaks
```bash
# Monitor growing IPC usage
while true; do
  date; ipcs -u | grep -E "(messages|bytes|segments)"
  sleep 5
done

# Find processes with open file descriptors
lsof | grep <process_name> | wc -l

# Check for orphaned IPC objects
ipcs -a | grep -v $(ps -eo pid --no-headers | tr '\n' '|' | sed 's/|$//')
```

#### Permission Issues
```bash
# Debug permission denied errors
strace -e trace=ipc <command> 2>&1 | grep EACCES

# Check umask settings
umask

# Verify user/group membership
id <username>
groups <username>
```

### DevOps IPC Monitoring and Automation

#### Automated IPC Health Checks
```bash
#!/bin/bash
# ipc_health_check.sh - Monitor IPC health

echo "=== IPC Health Check $(date) ==="

# Check for excessive IPC usage
IPC_COUNT=$(ipcs -a | grep -c "^0x")
if [ "$IPC_COUNT" -gt 100 ]; then
    echo "WARNING: High IPC object count: $IPC_COUNT"
fi

# Check for old IPC objects
ipcs -a -t | awk 'NR>3 && $6 < (systime() - 86400) {print "OLD IPC:", $0}'

# Monitor IPC memory usage
ipcs -m -u | grep -E "(bytes allocated|segments allocated)"

# Check process IPC usage
for pid in $(ps -eo pid --no-headers); do
    ipc_fds=$(lsof -p $pid 2>/dev/null | grep -c -E "(pipe|socket|FIFO)")
    if [ "$ipc_fds" -gt 50 ]; then
        echo "High IPC usage - PID: $pid, FDs: $ipc_fds"
    fi
done
```

### What is Cross Compilation?

Cross compilation is the process of compiling code on one architecture (the **host**) to run on a different architecture (the **target**).

- **Host System**: Your development machine (x86/x64 Linux, Windows, or macOS)
- **Target System**: The embedded device (ARM Cortex-M, RISC-V, etc.)

Cross compilation is necessary because embedded targets have:
- Limited computational power
- Different instruction set architectures (ISA)
- No operating system or a real-time OS
- Resource constraints (memory, storage)

The cross-compiler toolchain includes:
- **Cross-compiler**: Generates target-specific machine code
- **Cross-assembler**: Converts assembly to object files
- **Cross-linker**: Links object files and libraries
- **Cross-debugger**: Debugs applications on target hardware

### Troubleshooting

### GDB Permission Issues
```bash
# Fix ptrace permission denied
echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope

# Permanent fix
echo 'kernel.yama.ptrace_scope = 0' | sudo tee -a /etc/sysctl.conf
```

### Cross-Compilation Issues
- Verify toolchain installation and PATH
- Check target architecture flags
- Ensure proper library linking
- Validate linker scripts for embedded targets
